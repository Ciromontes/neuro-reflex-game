import { useState, useEffect, useRef, useCallback } from 'react';
import type { Phase, WordPair, FallingWord, Feedback, Particle, ConfettiPiece } from '../types';

export const useGameLogic = (phase: Phase, mode: 'training' | 'easy' | 'medium' | 'hard') => {
  // Estados del juego - TODOS los estados del original
  const [gameState, setGameState] = useState<'learning' | 'training' | 'easy' | 'medium' | 'hard' | 'paused' | 'gameover' | 'victory'>('learning');
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(phase.difficultyLevels[mode].lives);
  const [combo, setCombo] = useState(0);
  const [currentWord, setCurrentWord] = useState<WordPair | null>(null);
  const [fallingWords, setFallingWords] = useState<FallingWord[]>([]);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [feedback, setFeedback] = useState<Feedback | null>(null);
  const [particles, setParticles] = useState<Particle[]>([]);
  const [confetti, setConfetti] = useState<ConfettiPiece[]>([]);
  const [studiedWords, setStudiedWords] = useState<Set<string>>(new Set());
  const [missedWords, setMissedWords] = useState<WordPair[]>([]);
  const [correctCount, setCorrectCount] = useState(0);
  const [difficulty, setDifficulty] = useState<'easy' | 'medium' | 'hard'>('easy');
  const [isPaused, setIsPaused] = useState(false);
  const [shakeScreen, setShakeScreen] = useState(false);

  // Referencias
  const wordIdCounter = useRef(0);
  const fallTimerRef = useRef<NodeJS.Timeout | null>(null);
  const wordQueueRef = useRef<number[]>([]);
  const availableWordsRef = useRef<WordPair[]>([]);
  const currentCycleRef = useRef<WordPair[]>([]);

  // ConfiguraciÃ³n de dificultad (usar phase.difficultyConfig o valores por defecto)
  const difficultyConfig = phase.difficultyConfig || {
    easy: { speed: 8000, name: "FÃCIL", color: "#00ff87", livesForNext: 10 },
    medium: { speed: 5500, name: "MEDIO", color: "#00d4ff", livesForNext: 15 },
    hard: { speed: 3500, name: "DIFÃCIL", color: "#ff00ff", livesForNext: 20 }
  };

  // Inicializar ciclo de palabras sin repeticiÃ³n
  const initializeWordCycle = useCallback(() => {
    const shuffled = [...phase.wordPairs].sort(() => Math.random() - 0.5);
    currentCycleRef.current = shuffled;
    availableWordsRef.current = [...shuffled];
  }, [phase.wordPairs]);

  // Generar palabras que caen (CON DISTRACTORES ESPECÃFICOS DE CADA FASE)
  const generateFallingWords = useCallback((targetWord: WordPair): FallingWord[] => {
    const words: FallingWord[] = [];
    const numWords = 4;
    const positions = [20, 40, 60, 80];
    const shuffledPositions = [...positions].sort(() => Math.random() - 0.5);

    // Palabra correcta
    words.push({
      id: wordIdCounter.current++,
      text: targetWord.antonym,
      isCorrect: true,
      left: shuffledPositions[0]
    });

    // Obtener otros antÃ³nimos (excluyendo el actual)
    const otherAntonyms = phase.wordPairs
      .filter(w => w.antonym !== targetWord.antonym)
      .map(w => w.antonym);
    
    // Usar distractores especÃ­ficos de la fase
    const allDistractors = [...otherAntonyms, ...(phase.distractorWords || [])];
    const uniqueDistractors = [...new Set(allDistractors)]
      .filter(word => word !== targetWord.antonym);
    
    const shuffled = uniqueDistractors
      .sort(() => Math.random() - 0.5)
      .slice(0, numWords - 1);

    shuffled.forEach((distractor, index) => {
      words.push({
        id: wordIdCounter.current++,
        text: distractor,
        isCorrect: false,
        left: shuffledPositions[index + 1]
      });
    });

    return words;
  }, [phase.wordPairs, phase.distractorWords]);

  // Sintetizar voz (EXACTO AL ORIGINAL)
  const speakWord = useCallback((word: string, rate = 1) => {
    if (!soundEnabled || !window.speechSynthesis) return;
    
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = 'en-US';
    utterance.rate = rate;
    
    const setVoice = () => {
      const voices = window.speechSynthesis.getVoices();
      const englishVoice = voices.find(voice => 
        voice.lang === 'en-US' || 
        voice.lang === 'en-GB' || 
        voice.lang.startsWith('en-')
      );
      if (englishVoice) utterance.voice = englishVoice;
      
      setTimeout(() => {
        window.speechSynthesis.speak(utterance);
      }, 10);
    };
    
    if (window.speechSynthesis.getVoices().length > 0) {
      setVoice();
    } else {
      window.speechSynthesis.onvoiceschanged = setVoice;
    }
  }, [soundEnabled]);

  // Crear partÃ­culas (EXACTO AL ORIGINAL)
  const createParticles = useCallback((x: number, y: number) => {
    const newParticles: Particle[] = [];
    for (let i = 0; i < 20; i++) {
      newParticles.push({
        id: Math.random(),
        x,
        y,
        vx: (Math.random() - 0.5) * 15,
        vy: (Math.random() - 0.5) * 15
      });
    }
    setParticles(newParticles);
    setTimeout(() => setParticles([]), 1000);
  }, []);

  // Crear confetti (EXACTO AL ORIGINAL)
  const createConfetti = useCallback(() => {
    const newConfetti: ConfettiPiece[] = [];
    for (let i = 0; i < 100; i++) {
      newConfetti.push({
        id: Math.random(),
        x: Math.random() * 100,
        y: -10,
        color: ['#00ff87', '#00d4ff', '#ff00ff', '#ffd700', '#ff3d00'][Math.floor(Math.random() * 5)],
        delay: Math.random() * 0.5
      });
    }
    setConfetti(newConfetti);
    setTimeout(() => setConfetti([]), 5000);
  }, []);

  // Manejar click en palabra (CON TODA LA LÃ“GICA DE PUNTOS Y PROGRESIÃ“N)
  const handleWordClick = useCallback((word: FallingWord, event: React.MouseEvent) => {
    if (!['training', 'easy', 'medium', 'hard'].includes(gameState) || isPaused || !currentWord) return;

    // CRÃTICO: Limpiar timer inmediatamente para evitar solapamientos
    if (fallTimerRef.current) {
      clearTimeout(fallTimerRef.current);
      fallTimerRef.current = null;
    }

    // Limpiar palabras cayendo inmediatamente
    setFallingWords([]);

    const rect = event.currentTarget.getBoundingClientRect();
    const x = (rect.left + rect.width / 2) / window.innerWidth * 100;
    const y = (rect.top + rect.height / 2) / window.innerHeight * 100;

    if (word.isCorrect) {
      const points = 100 + (combo * 25);
      setScore(s => s + points);
      setCombo(c => c + 1);
      createParticles(x, y);
      
      setStudiedWords(prev => new Set([...prev, currentWord.target]));
      
      const newCorrectCount = correctCount + 1;
      setCorrectCount(newCorrectCount);
      
      // Sistema de vidas y progresiÃ³n de niveles (SOLO EN MODOS NO-TRAINING)
      if (gameState !== 'training') {
        if (newCorrectCount % 5 === 0) {
          const newLives = lives + 1;
          setLives(newLives);
          
          // ProgresiÃ³n de niveles (FÃCIL â†’ MEDIO â†’ DIFÃCIL)
          if (difficulty === 'easy' && newLives >= difficultyConfig.easy.livesForNext) {
            setTimeout(() => {
              setDifficulty('medium');
              setFeedback({
                type: 'levelup',
                text: 'ðŸŽ‰ Â¡NIVEL MEDIO DESBLOQUEADO! ðŸŽ‰',
                points: 'Velocidad aumentada'
              });
              setTimeout(() => {
                setFeedback(null);
                nextWord();
              }, 2500);
            }, 2000);
            return;
          } else if (difficulty === 'medium' && newLives >= difficultyConfig.medium.livesForNext) {
            setTimeout(() => {
              setDifficulty('hard');
              setFeedback({
                type: 'levelup',
                text: 'ðŸ”¥ Â¡NIVEL DIFÃCIL DESBLOQUEADO! ðŸ”¥',
                points: 'Â¡Velocidad ultra rÃ¡pida!'
              });
              setTimeout(() => {
                setFeedback(null);
                nextWord();
              }, 2500);
            }, 2000);
            return;
          } else if (difficulty === 'hard' && newLives >= difficultyConfig.hard.livesForNext) {
            setTimeout(() => {
              createConfetti();
              setGameState('victory');
            }, 2000);
            return;
          }
        }
      }
      
      speakWord(currentWord.target, 1.0);
      setTimeout(() => {
        speakWord(currentWord.antonym, 1.0);
      }, 800);
      
      setFeedback({
        type: 'correct',
        text: currentWord.spanish,
        points: `+${points}`
      });
      
      setTimeout(() => {
        setFeedback(null);
        nextWord();
      }, 2000);
    } else {
      setMissedWords(prev => [...prev, currentWord]);
      setCombo(0);
      
      const newLives = lives - 1;
      setLives(newLives);
      
      setShakeScreen(true);
      setTimeout(() => setShakeScreen(false), 500);
      
      speakWord("Wrong", 0.8);
      
      setFeedback({
        type: 'wrong',
        text: `Â¡NO! La respuesta es: ${currentWord.antonym}`,
        points: '-50'
      });

      setScore(s => Math.max(0, s - 50));
      
      if (newLives <= 0) {
        setTimeout(() => {
          setGameState('gameover');
          setFallingWords([]);
          if (fallTimerRef.current) {
            clearTimeout(fallTimerRef.current);
            fallTimerRef.current = null;
          }
        }, 1200);
      } else {
        setTimeout(() => {
          setFeedback(null);
          nextWord();
        }, 1500);
      }
    }
  }, [gameState, isPaused, currentWord, combo, correctCount, lives, difficulty, createParticles, createConfetti, speakWord, nextWord, difficultyConfig]);

  // Manejar palabra perdida (EXACTO AL ORIGINAL)
  const handleMissedWord = useCallback(() => {
    if (!['training', 'easy', 'medium', 'hard'].includes(gameState) || isPaused || !currentWord) return;

    // Limpiar palabras inmediatamente
    setFallingWords([]);

    setMissedWords(prev => [...prev, currentWord]);
    setCombo(0);
    
    const newLives = lives - 1;
    setLives(newLives);
    
    setShakeScreen(true);
    setTimeout(() => setShakeScreen(false), 500);
    
    setFeedback({
      type: 'missed',
      text: `Â¡PERDISTE! Era: ${currentWord.antonym}`,
      points: '-75'
    });

    setScore(s => Math.max(0, s - 75));
    
    if (newLives <= 0) {
      setTimeout(() => {
        setGameState('gameover');
        setFallingWords([]);
        if (fallTimerRef.current) {
          clearTimeout(fallTimerRef.current);
          fallTimerRef.current = null;
        }
      }, 1200);
    } else {
      setTimeout(() => {
        setFeedback(null);
        nextWord();
      }, 1500);
    }
  }, [gameState, isPaused, currentWord, lives, nextWord]);

  // Siguiente palabra con repeticiÃ³n espaciada (EXACTO AL ORIGINAL)
  const nextWord = useCallback(() => {
    let nextWordData: WordPair;
    
    // Sistema de repeticiÃ³n espaciada: cada 4 palabras, insertar una palabra fallada
    if (gameState !== 'training' && missedWords.length > 0 && wordQueueRef.current.length === 0) {
      // Tomar la palabra mÃ¡s antigua que se fallÃ³
      nextWordData = missedWords[0];
      setMissedWords(prev => prev.slice(1));
      
      // Resetear contador de cola
      wordQueueRef.current = [1, 2, 3, 4];
    } else {
      // Sacar la siguiente palabra de las disponibles
      if (availableWordsRef.current.length === 0) {
        // Si ya mostramos todas las palabras, reiniciar el ciclo
        initializeWordCycle();
      }
      
      // Tomar la primera palabra disponible
      nextWordData = availableWordsRef.current.shift()!;
      
      // Decrementar contador de cola si existe
      if (wordQueueRef.current.length > 0) {
        wordQueueRef.current.shift();
      }
    }
    
    setCurrentWord(nextWordData);
    
    setTimeout(() => {
      const words = generateFallingWords(nextWordData);
      setFallingWords(words);

      // Determinar velocidad segÃºn modo y dificultad
      let fallTime;
      if (gameState === 'training') {
        fallTime = difficultyConfig.easy.speed;
      } else {
        fallTime = difficultyConfig[difficulty].speed;
      }
      
      if (fallTimerRef.current) clearTimeout(fallTimerRef.current);
      fallTimerRef.current = setTimeout(() => {
        handleMissedWord();
      }, fallTime + 800); // Aumentado el margen para mejor detecciÃ³n
    }, 100);
  }, [gameState, missedWords, initializeWordCycle, generateFallingWords, difficulty, difficultyConfig, handleMissedWord]);

  // Iniciar juego (para cada modo)
  const startGame = useCallback((gameMode: 'training' | 'easy' | 'medium' | 'hard') => {
    setGameState(gameMode);
    setScore(0);
    setLives(phase.difficultyLevels[gameMode].lives);
    setCombo(0);
    setCorrectCount(0);
    setMissedWords([]);
    setStudiedWords(new Set());
    setCurrentWord(null);
    setFallingWords([]);
    setIsPaused(false);
    setDifficulty('easy'); // Resetear dificultad
    wordQueueRef.current = [];
    initializeWordCycle();
  }, [phase.difficultyLevels, initializeWordCycle]);

  // Iniciar entrenamiento (modo especial)
  const startTraining = useCallback(() => {
    startGame('training');
  }, [startGame]);

  // Terminar juego
  const endGame = useCallback(() => {
    setGameState('gameover');
    setFallingWords([]);
    if (fallTimerRef.current) {
      clearTimeout(fallTimerRef.current);
      fallTimerRef.current = null;
    }
  }, []);

  // Reiniciar juego completo
  const resetGame = useCallback(() => {
    setGameState('learning');
    setScore(0);
    setLives(5);
    setCombo(0);
    setDifficulty('easy');
    setCurrentWord(null);
    setFallingWords([]);
    setCorrectCount(0);
    setMissedWords([]);
    setStudiedWords(new Set());
    wordQueueRef.current = [];
    if (fallTimerRef.current) {
      clearTimeout(fallTimerRef.current);
      fallTimerRef.current = null;
    }
  }, []);

  // Pre-cargar voces para iOS (fix para problema de idioma)
  useEffect(() => {
    if (window.speechSynthesis) {
      const loadVoices = () => window.speechSynthesis.getVoices();
      loadVoices();
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = loadVoices;
      }
    }
  }, []);

  // Iniciar palabras cuando comienza el juego
  useEffect(() => {
    if (['training', 'easy', 'medium', 'hard'].includes(gameState) && !currentWord) {
      // Inicializar el ciclo de palabras
      initializeWordCycle();
      
      const timer = setTimeout(() => {
        const firstWord = availableWordsRef.current[0];
        setCurrentWord(firstWord);
        
        const words = generateFallingWords(firstWord);
        setFallingWords(words);

        // Determinar velocidad segÃºn modo y dificultad
        let fallTime;
        if (gameState === 'training') {
          fallTime = difficultyConfig.easy.speed;
        } else {
          fallTime = difficultyConfig[difficulty].speed;
        }
        
        fallTimerRef.current = setTimeout(() => {
          handleMissedWord();
        }, fallTime + 800); // Aumentado el margen de 500 a 800ms
      }, 100);
      
      return () => clearTimeout(timer);
    }
  }, [gameState, currentWord, initializeWordCycle, generateFallingWords, difficulty, difficultyConfig, handleMissedWord]);

  // Efecto para limpiar timers al desmontar
  useEffect(() => {
    return () => {
      if (fallTimerRef.current) {
        clearTimeout(fallTimerRef.current);
      }
    };
  }, []);

  return {
    gameState,
    setGameState,
    score,
    lives,
    combo,
    currentWord,
    fallingWords,
    soundEnabled,
    setSoundEnabled,
    feedback,
    particles,
    confetti,
    studiedWords,
    missedWords,
    correctCount,
    difficulty,
    isPaused,
    setIsPaused,
    shakeScreen,
    handleWordClick,
    startTraining,
    startGame,
    togglePause: () => setIsPaused(p => !p),
    quitGame: () => {
      if (fallTimerRef.current) {
        clearTimeout(fallTimerRef.current);
        fallTimerRef.current = null;
      }
      setIsPaused(false);
      setGameState('learning');
      setFallingWords([]);
    },
    resetGame,
    difficultyConfig
  };
};
